#!/bin/bash
# FaultMaven Self-Hosted CLI Wrapper
# Simplifies deployment and management of FaultMaven services

set -e

# Ensure script is run from the correct directory (where docker-compose.yml exists)
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Configuration
MIN_RAM_GB=8
REQUIRED_COMMANDS=("docker" "jq" "curl")

# Development mode detection
DEV_MODE=false
USE_PROD_IMAGES=false
COMPOSE_FILES="-f docker-compose.yml"

# CLI options
NO_COLOR=false
TAIL_LINES=""

# Health check endpoints: "port:service_name"
# Used by cmd_status() and cmd_verify() for consistency
HEALTH_CHECK_SERVICES=(
    "8001:Auth Service"
    "8002:Session Service"
    "8003:Case Service"
    "8004:Knowledge Service"
    "8005:Evidence Service"
    "8006:Agent Service"
    "8090:API Gateway"
    "3000:Dashboard"
)

# LLM provider environment variables and display names
# Order determines priority (first configured = primary provider)
LLM_PROVIDERS=(
    "OPENAI_API_KEY:OpenAI"
    "ANTHROPIC_API_KEY:Anthropic"
    "GROQ_API_KEY:Groq"
    "GEMINI_API_KEY:Gemini"
    "FIREWORKS_API_KEY:Fireworks"
    "HUGGINGFACE_API_KEY:HuggingFace"
    "OPENROUTER_API_KEY:OpenRouter"
    "LOCAL_LLM_API_KEY:Local LLM"
)

#######################################
# Utility Functions
#######################################

print_header() {
    echo -e "${BLUE}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${BLUE}‚ïë${NC}  FaultMaven Self-Hosted Manager      ${BLUE}‚ïë${NC}"
    echo -e "${BLUE}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
    if [ "$DEV_MODE" = true ]; then
        echo -e "${CYAN}üîß Development Mode: Building from local source${NC}"
    fi
    echo ""
}

print_success() {
    echo -e "${GREEN}‚úì${NC} $1"
}

print_error() {
    echo -e "${RED}‚úó${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}‚ö†${NC} $1"
}

print_info() {
    echo -e "${BLUE}‚Ñπ${NC} $1"
}

print_dev() {
    echo -e "${CYAN}üîß${NC} $1"
}

#######################################
# Development Mode Detection
#######################################

detect_dev_mode() {
    # Allow override to force production images (from command-line flag)
    if [ "${USE_PROD_IMAGES}" = "true" ]; then
        DEV_MODE=false
        COMPOSE_FILES="-f docker-compose.yml"
        print_info "Using production images from ghcr.io (--use-prod-images flag)"
        return
    fi

    # Check if docker-compose.dev.yml exists
    if [ ! -f docker-compose.dev.yml ]; then
        DEV_MODE=false
        return
    fi

    # Check if we're in a development workspace (ALL required repos must be present)
    local parent_dir="$(dirname "$SCRIPT_DIR")"

    # Required repositories for development mode (based on docker-compose.dev.yml)
    local required_repos=(
        "fm-core-lib"
        "fm-auth-service"
        "fm-session-service"
        "fm-case-service"
        "fm-knowledge-service"
        "fm-evidence-service"
        "fm-agent-service"
        "fm-api-gateway"
        "fm-job-worker"
        "faultmaven-dashboard"
    )

    local missing_repos=()
    for repo in "${required_repos[@]}"; do
        if [ ! -d "$parent_dir/$repo" ]; then
            missing_repos+=("$repo")
        fi
    done

    # Enable dev mode ONLY if ALL required repos are present
    if [ ${#missing_repos[@]} -eq 0 ]; then
        DEV_MODE=true
        COMPOSE_FILES="-f docker-compose.yml -f docker-compose.dev.yml"
    else
        DEV_MODE=false
        echo ""
        print_warning "Development mode requires ALL service repositories"
        echo ""
        echo "Missing repositories (${#missing_repos[@]} of ${#required_repos[@]}):"
        for repo in "${missing_repos[@]}"; do
            echo "  ‚úó $repo"
        done
        echo ""
        echo "You have two options:"
        echo ""
        echo "  Option 1: Clone missing repositories"
        echo "    Clone all missing repos as siblings to faultmaven-deploy/"
        echo "    Then run this command again"
        echo ""
        echo "  Option 2: Use production images (recommended for most users)"
        echo "    Run: ./faultmaven start --use-prod-images"
        echo "    This pulls pre-built images from ghcr.io (faster, no build needed)"
        echo ""
        exit 1
    fi
}

#######################################
# Pre-flight Checks
#######################################

check_dependencies() {
    print_info "Checking dependencies..."

    local all_present=true

    for cmd in "${REQUIRED_COMMANDS[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            print_error "$cmd is not installed"
            all_present=false
        else
            print_success "$cmd found"
        fi
    done

    if [ "$all_present" = false ]; then
        echo ""
        print_error "Missing required dependencies. Please install Docker and Docker Compose."
        echo "Visit: https://docs.docker.com/get-docker/"
        exit 1
    fi
}

check_docker_running() {
    if ! docker info &> /dev/null; then
        print_error "Docker daemon is not running"
        echo "Please start Docker Desktop or the Docker service"
        exit 1
    fi
    print_success "Docker daemon is running"
}

check_resources() {
    print_info "Checking system resources..."

    # Check available RAM (Linux/Mac compatible)
    if [[ "$OSTYPE" == "linux-gnu"* ]]; then
        local total_ram=$(free -g | awk '/^Mem:/{print $2}')
        local available_ram=$(free -g | awk '/^Mem:/{print $7}')
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        # macOS - Use sysctl for total physical RAM
        local total_ram_bytes=$(sysctl -n hw.memsize)
        local total_ram=$((total_ram_bytes / 1024 / 1024 / 1024))
        # Use total RAM as practical check (macOS memory management is complex)
        local available_ram=$total_ram
    else
        print_warning "Cannot determine RAM on this OS, skipping check"
        return
    fi

    if [ "$available_ram" -lt "$MIN_RAM_GB" ]; then
        print_warning "Only ${available_ram}GB RAM available (${MIN_RAM_GB}GB minimum recommended)"
        print_warning "FaultMaven may run slowly or fail to start"
        echo ""
        read -p "Continue anyway? (y/N) " -n 1 -r
        echo ""
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            print_info "Startup cancelled"
            exit 1
        fi
    else
        print_success "Sufficient RAM available (${available_ram}GB)"
    fi
}

check_env_file() {
    if [ ! -f .env ]; then
        print_warning ".env file not found"
        print_info "Creating .env from .env.example..."

        if [ -f .env.example ]; then
            cp .env.example .env
            print_success ".env file created"
            echo ""
            print_error "ACTION REQUIRED: Configure .env file before starting"
            echo ""
            echo "Edit .env and set these REQUIRED variables:"
            echo "  1. OPENAI_API_KEY=sk-... (or another LLM provider)"
            echo "  2. SERVER_HOST=192.168.x.x (your server's IP address)"
            echo ""
            echo "Then run: ./faultmaven start"
            exit 1
        else
            print_error ".env.example not found"
            exit 1
        fi
    fi

    # Source .env to check values
    # Use set -a to auto-export all variables, then source
    set -a
    source .env
    set +a

    # Check for required LLM API key (at least one provider must be configured)
    # The FIRST configured provider will be used as primary LLM
    local has_api_key=false
    local primary_provider=""

    for provider in "${LLM_PROVIDERS[@]}"; do
        local env_var="${provider%%:*}"
        local display_name="${provider#*:}"
        if [ -n "${!env_var}" ] && [ -z "$primary_provider" ]; then
            has_api_key=true
            primary_provider="$display_name"
        fi
    done

    if [ "$has_api_key" = false ]; then
        print_error "No LLM API key configured"
        echo ""
        echo "Edit .env and configure AT LEAST ONE provider:"
        echo "  OPENAI_API_KEY=sk-...              # OpenAI GPT"
        echo "  ANTHROPIC_API_KEY=sk-ant-...       # Anthropic Claude"
        echo "  GROQ_API_KEY=gsk-...               # Groq (FREE tier, ultra-fast!)"
        echo "  GEMINI_API_KEY=AIza...             # Google Gemini"
        echo "  FIREWORKS_API_KEY=fw_...           # Fireworks AI"
        echo "  HUGGINGFACE_API_KEY=hf_...         # HuggingFace (FREE, cold starts)"
        echo "  OPENROUTER_API_KEY=sk-or-...       # OpenRouter"
        echo "  LOCAL_LLM_API_KEY=not-needed       # Local (Ollama/LocalAI)"
        echo ""
        echo "The FIRST configured key will be used as primary LLM."
        echo "Additional keys serve as automatic fallbacks."
        echo ""
        exit 1
    fi

    # Check for required SERVER_HOST
    if [ -z "$SERVER_HOST" ]; then
        print_error "SERVER_HOST not configured"
        echo ""
        echo "Edit .env and set:"
        echo "  SERVER_HOST=192.168.x.x (your server's IP address)"
        echo ""
        echo "Examples:"
        echo "  SERVER_HOST=192.168.0.200    # Local network"
        echo "  SERVER_HOST=faultmaven.local # Hostname"
        echo ""
        exit 1
    fi

    # Warn about default credentials
    if [ "$DASHBOARD_PASSWORD" = "changeme123" ] || [ -z "$DASHBOARD_PASSWORD" ]; then
        echo ""
        print_warning "SECURITY WARNING: Using default dashboard password!"
        print_warning "Edit .env and set a strong DASHBOARD_PASSWORD before production use."
        echo ""
    fi

    print_success ".env file configured"
    print_info "Primary LLM Provider: $primary_provider"
    print_info "Server Host: $SERVER_HOST"
}

check_and_create_override() {
    if [ ! -f docker-compose.override.yml ]; then
        print_warning "docker-compose.override.yml not found (recommended for resource limits)"
        echo ""
        read -p "Create it now? (Y/n) " -n 1 -r
        echo ""
        if [[ ! $REPLY =~ ^[Nn]$ ]]; then
            print_info "Creating docker-compose.override.yml with resource limits..."
            cat > docker-compose.override.yml << 'EOF'
# Docker Compose Override - Resource Limits
# This file prevents FaultMaven from overwhelming your system
# Auto-generated by ./faultmaven script

services:
  # AI Agent Service - Most memory-intensive
  fm-agent-service:
    mem_limit: 1536m        # 1.5GB hard limit
    mem_reservation: 512m
    cpus: 1.0

  # Knowledge Service - Vector DB + embeddings
  fm-knowledge-service:
    mem_limit: 2048m        # 2GB hard limit
    mem_reservation: 1024m
    cpus: 1.0

  # ChromaDB - Vector database
  chromadb:
    mem_limit: 1024m        # 1GB hard limit
    mem_reservation: 512m
    cpus: 0.5

  # Redis - Session store
  redis:
    mem_limit: 512m
    mem_reservation: 256m
    cpus: 0.25
EOF
            print_success "Resource limits configured"
        fi
    else
        print_success "Resource limits configured (docker-compose.override.yml)"
    fi
}

#######################################
# Core Commands
#######################################

cmd_build() {
    print_header

    if [ "$DEV_MODE" != true ]; then
        print_error "Build command only available in development mode"
        echo ""
        echo "Development mode requires:"
        echo "  1. docker-compose.dev.yml file in this directory"
        echo "  2. At least 3 service repositories in parent directory"
        echo "     (fm-auth-service, fm-session-service, fm-case-service, etc.)"
        echo ""
        echo "Current setup: Production mode (using pre-built images from GHCR)"
        echo ""
        echo "To force production images even with local repos:"
        echo "  ./faultmaven start --use-prod-images"
        exit 1
    fi

    local service="$1"

    if [ -z "$service" ]; then
        # Build all services
        print_dev "Building all FaultMaven services from local source..."
        echo ""

        if docker compose $COMPOSE_FILES build; then
            echo ""
            print_success "All services built successfully"
            echo ""
            echo "Next steps:"
            echo "  ./faultmaven start    # Start with newly built images"
        else
            echo ""
            print_error "Build failed"
            exit 1
        fi
    else
        # Build specific service
        print_dev "Building $service from local source..."
        echo ""

        if docker compose $COMPOSE_FILES build "$service"; then
            echo ""
            print_success "$service built successfully"
            echo ""
            echo "Next steps:"
            echo "  ./faultmaven start    # Start services (including rebuilt $service)"
            echo "  docker compose $COMPOSE_FILES restart $service  # Just restart this service"
        else
            echo ""
            print_error "Build failed for $service"
            exit 1
        fi
    fi
}

cmd_start() {
    print_header
    local start_time=$(date +%s)
    echo "Starting FaultMaven services..."
    echo ""

    check_dependencies
    check_docker_running
    check_resources
    check_env_file
    check_and_create_override

    echo ""
    if [ "$DEV_MODE" = true ]; then
        print_dev "Development mode: Building services from local source..."
        print_dev "This may take several minutes on first build..."
    else
        print_info "Pulling pre-built images from GitHub Container Registry..."
        print_info "(No authentication required - all images are public)"
    fi
    echo ""

    if docker compose $COMPOSE_FILES up -d; then
        echo ""
        print_info "Waiting for services to become healthy (up to 120 seconds)..."
        echo ""

        # Wait for services to pass health checks
        # Our health checks need: 40s start_period + 60s (3x30s checks) = 100s total
        # Add 20s buffer for slower systems = 120s timeout
        sleep 5  # Give containers time to start

        max_wait=120
        elapsed=0
        all_healthy=false

        while [ $elapsed -lt $max_wait ]; do
            # Check if all services with health checks are healthy
            # Count services that are NOT healthy (either unhealthy or starting)
            # Note: docker compose ps --format json outputs NDJSON (one JSON object per line)
            # We use jq -s to slurp all objects into an array, then filter
            not_healthy=$(docker compose ps --format json 2>/dev/null | jq -s '[.[] | select(.Health != null and .Health != "healthy")] | length' 2>/dev/null || echo "0")

            # Also verify at least some services are running
            total_services=$(docker compose ps --format json 2>/dev/null | jq -s 'length' 2>/dev/null || echo "0")

            if [ "$not_healthy" -eq 0 ] && [ "$total_services" -gt 0 ]; then
                all_healthy=true
                break
            fi

            echo -n "."
            sleep 5
            elapsed=$((elapsed + 5))
        done

        echo ""

        if [ "$all_healthy" = true ]; then
            local end_time=$(date +%s)
            local duration=$((end_time - start_time))
            echo ""
            print_success "FaultMaven services started successfully! (${duration}s)"
            echo ""
            echo "Next steps:"
            echo "  1. Check status:  ./faultmaven status"
            echo "  2. View logs:     ./faultmaven logs"
            echo "  3. Run tests:     ./faultmaven verify"
            echo "  4. Access services:"
            echo "     - API Gateway: http://$SERVER_HOST:8090/docs"
            echo "     - Dashboard:   http://$SERVER_HOST:3000"
            echo ""
            if [ "$DEV_MODE" = true ]; then
                print_dev "Development mode active - changes to code will require rebuild"
                echo ""
            fi
        else
            echo ""
            print_warning "Services started but some are still initializing"
            echo ""
            echo "This might not be an issue, as it may sometimes take over 120 seconds for services to become fully healthy."
            echo "Run './faultmaven status' in 30 seconds to verify all services are up."
            echo ""
        fi
    else
        echo ""
        print_error "Failed to start services"
        echo "Run './faultmaven logs' to see error details"
        exit 1
    fi
}

cmd_stop() {
    print_header
    echo "Stopping FaultMaven services..."
    echo ""

    if docker compose $COMPOSE_FILES down; then
        print_success "Services stopped"
        echo ""
        print_info "Data preserved in ./data directory"
        print_info "Run './faultmaven start' to restart"
    else
        print_error "Failed to stop services"
        exit 1
    fi
}

cmd_status() {
    print_header
    echo "Service Status:"
    echo ""

    docker compose ps

    echo ""
    echo "Health Checks:"
    echo ""

    for service in "${HEALTH_CHECK_SERVICES[@]}"; do
        local port="${service%%:*}"
        local name="${service#*:}"

        # Dashboard serves static files and uses "/" as health check, not "/health"
        local endpoint="/health"
        if [ "$port" = "3000" ]; then
            endpoint="/"
        fi

        if curl -sf "http://localhost:$port$endpoint" > /dev/null 2>&1; then
            print_success "$name (port $port)"
        else
            print_error "$name (port $port) - Not responding"
        fi
    done

    echo ""

    # Check data directory
    if [ -d ./data ]; then
        local db_size=$(du -sh ./data 2>/dev/null | cut -f1)
        print_info "Data directory size: $db_size"
    fi
}

cmd_logs() {
    print_header

    local tail_opt=""
    if [ -n "$TAIL_LINES" ]; then
        tail_opt="--tail $TAIL_LINES"
    fi

    if [ -z "$1" ]; then
        if [ -n "$TAIL_LINES" ]; then
            echo "Showing last $TAIL_LINES lines from all services (Ctrl+C to exit)..."
        else
            echo "Streaming logs from all services (Ctrl+C to exit)..."
        fi
        echo ""
        docker compose logs -f $tail_opt
    else
        if [ -n "$TAIL_LINES" ]; then
            echo "Showing last $TAIL_LINES lines from $1 (Ctrl+C to exit)..."
        else
            echo "Streaming logs from $1 (Ctrl+C to exit)..."
        fi
        echo ""
        docker compose logs -f $tail_opt "$1"
    fi
}

cmd_kill() {
    print_header
    echo "Force-killing all FaultMaven containers..."
    echo ""

    # Get all FaultMaven-related container IDs
    local containers=$(docker ps -a --filter "label=com.docker.compose.project=faultmaven-deploy" --format "{{.ID}}" 2>/dev/null)

    if [ -z "$containers" ]; then
        containers=$(docker ps -a --filter "name=faultmaven" --format "{{.ID}}" 2>/dev/null)
    fi

    if [ -n "$containers" ]; then
        print_info "Killing containers..."
        echo "$containers" | xargs docker kill 2>/dev/null || true

        print_info "Removing containers..."
        echo "$containers" | xargs docker rm -f 2>/dev/null || true

        print_success "All FaultMaven containers killed and removed"
    else
        print_info "No FaultMaven containers found"
    fi

    # Also try compose down just to be sure
    docker compose down 2>/dev/null || true

    echo ""
    print_info "Data preserved in ./data directory"
    print_info "Run './faultmaven start' to restart"
}

cmd_prune() {
    print_header
    print_warning "This will remove:"
    echo "  - All stopped FaultMaven containers"
    echo "  - All orphaned containers (detached from compose)"
    echo "  - All dangling/unused FaultMaven images"
    echo "  - All unused Docker networks"
    echo "  - All build cache (speeds up future builds)"
    echo ""
    echo "Data in ./data directory will be preserved"
    echo ""
    read -p "Continue? (y/N) " -n 1 -r
    echo ""

    if [[ $REPLY =~ ^[Yy]$ ]]; then
        echo ""

        # Stop and remove all containers
        print_info "Removing containers..."
        docker compose down --remove-orphans 2>/dev/null || true

        # Remove FaultMaven images
        print_info "Removing FaultMaven images..."
        docker images --filter "reference=faultmaven-deploy-*" --format "{{.ID}}" | xargs -r docker rmi -f 2>/dev/null || true
        docker images --filter "reference=ghcr.io/faultmaven/*" --format "{{.ID}}" | xargs -r docker rmi -f 2>/dev/null || true

        # Remove dangling images
        print_info "Removing dangling images..."
        docker image prune -f 2>/dev/null || true

        # Remove unused networks
        print_info "Removing unused networks..."
        docker network prune -f 2>/dev/null || true

        # Remove build cache
        print_info "Removing build cache..."
        docker builder prune -f 2>/dev/null || true

        print_success "Docker cleanup complete"
        echo ""

        # Show space reclaimed
        print_info "Checking disk space..."
        docker system df

        echo ""
        print_info "Data preserved in ./data directory"
        print_info "Run './faultmaven start' to rebuild and restart"
    else
        print_info "Prune cancelled"
    fi
}

cmd_nuke() {
    print_header
    print_warning "NUCLEAR OPTION - This will:"
    echo "  - Kill all FaultMaven containers"
    echo "  - Remove all FaultMaven images and volumes"
    echo "  - Remove ALL Docker build cache (affects other projects!)"
    echo "  - Remove ALL unused Docker resources system-wide"
    echo "  - DELETE ./data directory (all cases, evidence, knowledge base)"
    echo ""
    print_error "This is destructive and affects your entire Docker installation!"
    echo ""
    read -p "Are you ABSOLUTELY sure? Type 'NUKE' to confirm: " confirm

    if [ "$confirm" = "NUKE" ]; then
        echo ""

        # Kill all FaultMaven containers
        print_info "Killing all FaultMaven containers..."
        docker compose down -v --remove-orphans 2>/dev/null || true
        docker ps -a --filter "name=faultmaven" --format "{{.ID}}" | xargs -r docker rm -f 2>/dev/null || true

        # Remove all FaultMaven images
        print_info "Removing all FaultMaven images..."
        docker images --filter "reference=faultmaven*" --format "{{.ID}}" | xargs -r docker rmi -f 2>/dev/null || true
        docker images --filter "reference=ghcr.io/faultmaven/*" --format "{{.ID}}" | xargs -r docker rmi -f 2>/dev/null || true

        # Remove data directory
        if [ -d ./data ]; then
            print_info "Removing data directory..."
            rm -rf ./data
        fi

        # Remove override file
        if [ -f docker-compose.override.yml ]; then
            print_info "Removing docker-compose.override.yml..."
            rm -f docker-compose.override.yml
            print_info "Override file removed - next start will recreate it"
        fi

        # System-wide Docker cleanup (AGGRESSIVE)
        print_warning "Running system-wide Docker cleanup..."
        docker system prune -a -f --volumes 2>/dev/null || true

        print_success "Nuclear cleanup complete - FaultMaven obliterated"
        echo ""
        print_info "Disk space reclaimed:"
        docker system df
        echo ""
        print_warning "You'll need to rebuild everything with './faultmaven start'"
        if [ "$DEV_MODE" = true ]; then
            print_warning "First build will take 10-15 minutes (building from source)"
        else
            print_warning "First start will take 2-3 minutes (pulling images)"
        fi
    else
        print_info "Nuke cancelled - phew!"
    fi
}

cmd_verify() {
    print_header
    print_info "Running FaultMaven verification tests..."
    echo ""

    # Source .env to get SERVER_HOST
    if [ ! -f .env ]; then
        print_error ".env file not found"
        echo "Run './faultmaven start' first"
        exit 1
    fi
    set -a
    source .env
    set +a

    # Give ChromaDB extra time to stabilize
    # ChromaDB has no health check, so Knowledge Service may report healthy
    # before ChromaDB is fully ready to accept connections
    print_info "Waiting for services to stabilize (15 seconds)..."
    sleep 15
    echo ""

    # Use localhost for local testing (we're on the server)
    local API_BASE="http://localhost:8090/api/v1"
    local test_failed=false

    # Test 1: Health checks
    print_info "Testing service health endpoints..."

    local all_healthy=true
    for service in "${HEALTH_CHECK_SERVICES[@]}"; do
        local port="${service%%:*}"
        local name="${service#*:}"

        # Dashboard serves static files and uses "/" as health check, not "/health"
        local endpoint="/health"
        if [ "$port" = "3000" ]; then
            endpoint="/"
        fi

        if curl -sf "http://localhost:$port$endpoint" > /dev/null 2>&1; then
            print_success "$name"
        else
            print_error "$name - Not responding"
            all_healthy=false
            test_failed=true
        fi
    done

    if [ "$all_healthy" = false ]; then
        echo ""
        print_error "Some services are unhealthy. Run './faultmaven status' for details."
        exit 1
    fi

    echo ""

    # Test 2: Create a test case
    print_info "Creating test case..."
    local case_response=$(curl -sf -X POST "$API_BASE/cases" \
        -H "Content-Type: application/json" \
        -d '{
            "title": "Verification Test Case",
            "description": "Automated test to verify FaultMaven installation",
            "user_id": "verify_test_user"
        }' 2>/dev/null)

    if [ -z "$case_response" ]; then
        print_error "Failed to create test case"
        test_failed=true
    else
        local case_id=$(echo "$case_response" | grep -o '"case_id":"[^"]*"' | head -1 | cut -d'"' -f4)
        if [ -n "$case_id" ]; then
            print_success "Case created (ID: $case_id)"
        else
            print_error "Case response invalid"
            test_failed=true
        fi
    fi

    echo ""

    # Test 3: Upload test evidence
    if [ -n "$case_id" ]; then
        print_info "Uploading test evidence..."

        # Create a test log file
        local test_log="/tmp/faultmaven_test_$(date +%s).log"
        cat > "$test_log" << 'EOF'
2025-11-26 10:00:00 ERROR Application failed to start
2025-11-26 10:00:01 ERROR Connection refused: database unreachable
2025-11-26 10:00:02 WARN  Retrying connection (attempt 1/3)
2025-11-26 10:00:05 ERROR Connection timeout after 3 seconds
EOF

        local upload_response=$(curl -sf -X POST "$API_BASE/evidence" \
            -F "file=@$test_log" \
            -F "case_id=$case_id" \
            -F "evidence_type=log" 2>/dev/null)

        if [ -n "$upload_response" ]; then
            print_success "Evidence uploaded"
        else
            print_error "Failed to upload evidence"
            test_failed=true
        fi

        # Clean up test file
        rm -f "$test_log"
        echo ""
    fi

    # Test 4: Query AI agent
    if [ -n "$case_id" ]; then
        print_info "Testing AI agent endpoint..."

        # Use correct endpoint: /api/v1/agent/chat/{case_id}
        local agent_response=$(curl -s -X POST "$API_BASE/agent/chat/$case_id" \
            -H "Content-Type: application/json" \
            -d "{
                \"message\": \"What does the error log indicate?\"
            }" 2>/dev/null)

        if [ -n "$agent_response" ]; then
            # Check if response contains an error
            if echo "$agent_response" | grep -q '"error"\|"detail"'; then
                print_error "AI agent endpoint returned error: $(echo "$agent_response" | head -c 100)"
                test_failed=true
            else
                print_success "AI agent endpoint operational"
            fi
        else
            print_error "AI agent endpoint not responding"
            test_failed=true
        fi
        echo ""
    fi

    # Test 5: Knowledge base search
    print_info "Testing knowledge base endpoint..."
    local kb_response=$(curl -s -X POST "$API_BASE/knowledge/search" \
        -H "Content-Type: application/json" \
        -d '{
            "query": "database connection error",
            "search_mode": "keyword",
            "limit": 5
        }' 2>/dev/null)

    if [ -n "$kb_response" ]; then
        # Check if response contains an error
        if echo "$kb_response" | grep -q '"error"\|"detail"'; then
            print_error "Knowledge base endpoint returned error: $(echo "$kb_response" | head -c 100)"
            test_failed=true
        elif echo "$kb_response" | grep -q '"results"'; then
            print_success "Knowledge base endpoint operational"
        else
            print_error "Knowledge base response invalid"
            test_failed=true
        fi
    else
        print_error "Knowledge base endpoint not responding"
        test_failed=true
    fi

    echo ""

    # Final verdict
    if [ "$test_failed" = false ]; then
        echo ""
        print_success "All tests passed! FaultMaven is ready to use."
        echo ""
        echo "Next steps:"
        echo "  1. Install browser extension (see README.md)"
        echo "  2. Access dashboard: http://$SERVER_HOST:3000"
        echo "  3. API Gateway: http://$SERVER_HOST:8090/docs"
        echo ""
    else
        echo ""
        print_error "Some tests failed. Troubleshooting steps:"
        echo "  1. Check service logs: ./faultmaven logs"
        echo "  2. Verify .env configuration"
        echo "  3. Ensure LLM API key is valid"
        echo "  4. Check system resources: docker stats"
        echo ""
        exit 1
    fi
}

cmd_restart() {
    print_header
    local service="$1"

    if [ -z "$service" ]; then
        echo "Restarting all FaultMaven services..."
        echo ""

        if docker compose $COMPOSE_FILES restart; then
            print_success "All services restarted"
            echo ""
            print_info "Run './faultmaven status' to verify health"
        else
            print_error "Failed to restart services"
            exit 1
        fi
    else
        echo "Restarting $service..."
        echo ""

        if docker compose $COMPOSE_FILES restart "$service"; then
            print_success "$service restarted"
            echo ""
            print_info "Run './faultmaven status' to verify health"
        else
            print_error "Failed to restart $service"
            exit 1
        fi
    fi
}

cmd_clean() {
    print_header
    print_warning "This will PERMANENTLY DELETE all data including:"
    echo "  - All cases and troubleshooting sessions"
    echo "  - All uploaded evidence files"
    echo "  - All knowledge base documents"
    echo "  - SQLite database"
    echo ""
    echo "Docker images and containers will be preserved (use 'prune' to remove)"
    echo ""
    read -p "Are you sure? Type 'DELETE' to confirm: " confirm

    if [ "$confirm" = "DELETE" ]; then
        echo ""
        print_info "Stopping services..."
        docker compose down -v

        if [ -d ./data ]; then
            print_info "Removing data directory..."
            rm -rf ./data
        fi

        print_success "FaultMaven data has been deleted"
        echo ""
        print_info "Docker images preserved - restart will be fast"
        print_info "Run './faultmaven start' to start fresh"
    else
        print_info "Clean cancelled"
    fi
}

cmd_version() {
    local version="1.0.0"
    local git_hash=""
    local git_date=""

    # Try to get git info if available
    if command -v git &> /dev/null && [ -d .git ]; then
        git_hash=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
        git_date=$(git log -1 --format="%ci" 2>/dev/null | cut -d' ' -f1 || echo "unknown")
    fi

    echo "FaultMaven CLI v${version}"
    if [ -n "$git_hash" ] && [ "$git_hash" != "unknown" ]; then
        echo "Commit: ${git_hash} (${git_date})"
    fi
    echo ""
    echo "Repository: https://github.com/FaultMaven/faultmaven-deploy"
}

cmd_help() {
    print_header
    echo "Usage: ./faultmaven [command] [options]"
    echo ""
    echo "Service Management:"
    echo "  start [--use-prod-images]   Start all FaultMaven services"
    echo "  stop                        Stop all services (preserves data and images)"
    echo "  restart [service]           Restart all or specific service"
    echo "  status                      Show service status and health checks"
    echo "  verify                      Run end-to-end verification tests"
    echo "  logs [service] [--tail N]   Stream logs (optionally limit to last N lines)"
    echo ""
    echo "Development Commands:"
    echo "  build [service]             Build services from local source (dev mode only)"
    echo "                              Omit [service] to build all services"
    echo ""
    echo "Cleanup Commands (in order of severity):"
    echo "  clean                       Delete data only (preserves Docker images)"
    echo "  kill                        Force-kill all containers (preserves data)"
    echo "  prune                       Remove containers + images + build cache"
    echo "  nuke                        ‚ò¢Ô∏è  NUCLEAR: Delete everything"
    echo ""
    echo "Information:"
    echo "  version                     Show CLI version and git commit"
    echo "  help                        Show this help message"
    echo ""
    echo "Options:"
    echo "  --use-prod-images           Force use of production images from GHCR"
    echo "  --no-color                  Disable colored output (useful for CI/logs)"
    echo "  --tail N                    Limit log output to last N lines (with logs command)"
    echo ""
    echo "Examples:"
    echo "  ./faultmaven start                    # Start (auto-detect dev/prod mode)"
    echo "  ./faultmaven start --use-prod-images  # Force production images"
    echo "  ./faultmaven restart fm-agent-service # Restart specific service"
    echo "  ./faultmaven build fm-agent-service   # Build single service (dev mode)"
    echo "  ./faultmaven status                   # Check health of all services"
    echo "  ./faultmaven logs fm-agent-service    # View agent service logs"
    echo "  ./faultmaven logs --tail 100          # View last 100 lines from all services"
    echo "  ./faultmaven --no-color status        # Status without colors (for CI)"
    echo ""
    echo "Development Mode:"
    echo "  Automatically enabled when ALL 10 required repositories are present:"
    echo "    fm-core-lib, fm-auth-service, fm-session-service, fm-case-service,"
    echo "    fm-knowledge-service, fm-evidence-service, fm-agent-service,"
    echo "    fm-api-gateway, fm-job-worker, faultmaven-dashboard"
    echo ""
    echo "  If ANY repositories are missing:"
    echo "    - Script exits with error showing which repos are missing"
    echo "    - Two options: clone missing repos OR use --use-prod-images"
    echo ""
    echo "  When enabled, builds services from local source instead of pulling from GHCR"
    echo ""
    echo "Cleanup Decision Guide:"
    echo "  - Misbehaving service?       ‚Üí ./faultmaven kill"
    echo "  - Want fresh data?           ‚Üí ./faultmaven clean"
    echo "  - Low on disk space?         ‚Üí ./faultmaven prune"
    echo "  - Total rebuild needed?      ‚Üí ./faultmaven nuke"
    echo ""
}

#######################################
# Main
#######################################

# Parse flags and extract command + args
COMMAND=""
ARGS=()
SKIP_NEXT=false
for ((i=1; i<=$#; i++)); do
    if [ "$SKIP_NEXT" = true ]; then
        SKIP_NEXT=false
        continue
    fi

    arg="${!i}"
    next_i=$((i + 1))
    next_arg="${!next_i:-}"

    case $arg in
        --use-prod-images)
            USE_PROD_IMAGES=true
            ;;
        --no-color)
            NO_COLOR=true
            # Disable colors
            RED=''
            GREEN=''
            YELLOW=''
            BLUE=''
            CYAN=''
            NC=''
            ;;
        --tail)
            if [ -n "$next_arg" ] && [[ "$next_arg" =~ ^[0-9]+$ ]]; then
                TAIL_LINES="$next_arg"
                SKIP_NEXT=true
            else
                echo "Error: --tail requires a numeric argument"
                exit 1
            fi
            ;;
        --tail=*)
            TAIL_LINES="${arg#*=}"
            if ! [[ "$TAIL_LINES" =~ ^[0-9]+$ ]]; then
                echo "Error: --tail requires a numeric argument"
                exit 1
            fi
            ;;
        -h|--help)
            # Allow -h and --help to work as command
            if [ -z "$COMMAND" ]; then
                COMMAND="help"
            fi
            ;;
        -*)
            echo "Warning: Unknown flag '$arg' (ignored)"
            ;;
        *)
            # Non-flag arguments
            if [ -z "$COMMAND" ]; then
                COMMAND="$arg"
            else
                ARGS+=("$arg")
            fi
            ;;
    esac
done

# Detect development mode (respects --use-prod-images flag)
detect_dev_mode

# Execute command
case "${COMMAND:-}" in
    build)
        cmd_build "${ARGS[0]:-}"
        ;;
    start)
        cmd_start
        ;;
    stop)
        cmd_stop
        ;;
    restart)
        cmd_restart "${ARGS[0]:-}"
        ;;
    status)
        cmd_status
        ;;
    verify)
        cmd_verify
        ;;
    logs)
        cmd_logs "${ARGS[0]:-}"
        ;;
    kill)
        cmd_kill
        ;;
    prune)
        cmd_prune
        ;;
    nuke)
        cmd_nuke
        ;;
    clean)
        cmd_clean
        ;;
    version|--version|-v)
        cmd_version
        ;;
    help|--help|-h|"")
        cmd_help
        ;;
    *)
        print_error "Unknown command: ${COMMAND}"
        echo ""
        cmd_help
        exit 1
        ;;
esac
